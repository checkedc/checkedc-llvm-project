//=--3C.cpp-------------------------------------------------------*- C++-*-===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//
//
// Implementation of various method in 3C.h
//
//===----------------------------------------------------------------------===//

#include "clang/3C/3C.h"
#include "clang/3C/3CGlobalOptions.h"
#include "clang/3C/ArrayBoundsInferenceConsumer.h"
#include "clang/3C/ConstraintBuilder.h"
#include "clang/3C/IntermediateToolHook.h"
#include "clang/3C/RewriteUtils.h"
#include "clang/Frontend/ASTConsumers.h"
#include "clang/Frontend/VerifyDiagnosticConsumer.h"
#include "clang/Tooling/ArgumentsAdjusters.h"
#include "llvm/Support/TargetSelect.h"

using namespace clang::driver;
using namespace clang::tooling;
using namespace clang;
using namespace llvm;

// Suffixes for constraint output files.ParameterGatherer
#define INITIAL_OUTPUT_SUFFIX "_initial_constraints"
#define FINAL_OUTPUT_SUFFIX "_final_output"
#define BEFORE_SOLVING_SUFFIX "_before_solving_"
#define AFTER_SUBTYPING_SUFFIX "_after_subtyping_"

std::set<std::string> FilePaths;

struct _3COptions _3COpts;

static CompilationDatabase *CurrCompDB = nullptr;
static tooling::CommandLineArguments SourceFiles;

// _3CDiagnosticConsumer is a wrapper DiagnosticConsumer that delays the
// EndSourceFile callback until 3C's analysis is complete, making it possible to
// use VerifyDiagnosticConsumer to verify diagnostics generated by 3C.
//
// Normally, the AST parsing process calls BeginSourceFile, passes `expected-*`
// directives and generated diagnostics to VerifyDiagnosticConsumer as they
// occur, and then calls EndSourceFile, which triggers the verification. But 3C
// does not perform its analysis (and generate diagnostics) until after AST
// parsing, so we need to delay the EndSourceFile callback until 3C is done
// generating diagnostics. The alternative of putting another
// BeginSourceFile/EndSourceFile pair around 3C's diagnostics would be difficult
// because VerifyDiagnosticConsumer would expect us to pass the `expected-*`
// directives again.
//
// _3CDiagnosticConsumer serves one additional purpose: its NumErrors field
// counts the errors originally generated by the compiler or 3C so that 3C can
// stop after a stage that generates an error regardless of whether the error
// was "expected", since it might not be safe to continue the analysis after an
// error. (In contrast, NumErrors of a VerifyDiagnosticConsumer gives the status
// of diagnostic verification and will be 0 until verification is completed.) It
// may work to use DiagnosticsEngine::hasErrorOccurred for this instead.
//
// Currently, diagnostic verification is per translation unit. In our few
// multi-translation-unit tests, ensuring that the `expected-*` directives are
// in the right translation units can sometimes be a hassle. But it's unclear
// whether it would be feasible to share all the necessary objects across
// translation units to perform a single verification.
//
// _3CDiagnosticConsumer can also wrap an ordinary DiagnosticConsumer when we
// aren't verifying diagnostics. In that case, diagnostics with source locations
// still need to be generated in a BeginSourceFile/EndSourceFile interval, so
// delaying the EndSourceFile (as we do) is OK, and starting a new
// BeginSourceFile/EndSourceFile interval after AST parsing would also be OK.
// _3CDiagnosticConsumer doesn't actually need to know whether diagnostic
// verification is enabled, because the underlying DiagnosticConsumer's
// getNumErrors() gives us the correct post-verification status either way.
//
// See clang/docs/checkedc/3C/clang-tidy.md#_3c-name-prefix
// NOLINTNEXTLINE(readability-identifier-naming)
class _3CDiagnosticConsumer : public DiagnosticConsumer {
  std::unique_ptr<DiagnosticConsumer> UnderlyingConsumer;

  // In general, a DiagnosticConsumer can be used for more than one source file,
  // but we use _3CDiagnosticConsumer for only one file, so we can use this
  // simple state machine.
  enum State { S_Startup, S_ASTParsing, S_3CAnalysis, S_Done };
  State CurrentState = S_Startup;

public:
  _3CDiagnosticConsumer(DiagnosticsEngine &Engine)
      : UnderlyingConsumer(Engine.takeClient()) {
    // This code currently only supports the default LibTooling setup in which
    // the ClangTool has no global DiagnosticConsumer, so
    // CompilerInstance::createDiagnostics creates one owned by the
    // DiagnosticsEngine. If we needed to support the case in which the
    // DiagnosticConsumer isn't owned, we could use an "UnderlyingConsumerOwner"
    // pattern like VerifyDiagnosticConsumer does.
    assert(UnderlyingConsumer);
  }

  void BeginSourceFile(const LangOptions &LangOpts,
                       const Preprocessor *PP) override {
    assert(CurrentState == S_Startup);
    CurrentState = S_ASTParsing;
    UnderlyingConsumer->BeginSourceFile(LangOpts, PP);
  }

  void EndSourceFile() override {
    assert(CurrentState == S_ASTParsing);
    CurrentState = S_3CAnalysis;
    // Delay forwarding the EndSourceFile callback.
  }

  void HandleDiagnostic(DiagnosticsEngine::Level DiagLevel,
                        const Diagnostic &Info) override {
    // Count the originally generated diagnostics.
    DiagnosticConsumer::HandleDiagnostic(DiagLevel, Info);
    UnderlyingConsumer->HandleDiagnostic(DiagLevel, Info);
  }

  // Returns true if this translation unit was successful after diagnostic
  // verification, i.e., verification is enabled and it succeeded, or
  // verification is disabled and there were no errors. The caller must check
  // _3CInterface::HadNonDiagnosticError separately.
  bool finish3CAnalysis() {
    assert(CurrentState == S_3CAnalysis);
    CurrentState = S_Done;
    UnderlyingConsumer->EndSourceFile();
    return UnderlyingConsumer->getNumErrors() == 0;
  }

  ~_3CDiagnosticConsumer() override {
    // We considered asserting that the state is S_Done here, but if
    // ASTUnit::LoadFromCompilerInvocation fails and returns null, the
    // _3CDiagnosticConsumer may be destructed without reaching S_Done. However,
    // even without such an assertion, we're still well protected against
    // forgetting to finish verification and missing an error because if the
    // ASTUnit is null, _3CInterface::parseASTs will record a "non-diagnostic
    // error", while if the ASTUnit is non-null, it will get added to
    // _3CInterface::ASTs and determineExitCode will call finish3CAnalysis. (And
    // the _3CInterface destructor enforces that determineExitCode is called.)
  }
};

// Based on LibTooling's ASTBuilderAction but does several custom things that we
// need.
//
// See clang/docs/checkedc/3C/clang-tidy.md#_3c-name-prefix
// NOLINTNEXTLINE(readability-identifier-naming)
class _3CASTBuilderAction : public ToolAction {
  std::vector<std::unique_ptr<ASTUnit>> &ASTs;

public:
  _3CASTBuilderAction(std::vector<std::unique_ptr<ASTUnit>> &ASTs)
      : ASTs(ASTs) {}

  bool runInvocation(std::shared_ptr<CompilerInvocation> Invocation,
                     FileManager *Files,
                     std::shared_ptr<PCHContainerOperations> PCHContainerOps,
                     DiagnosticConsumer *DiagConsumer) override {

    // Adjust some compiler options. This is similar to what we could do with
    // a LibTooling ArgumentsAdjuster, but we access the options in their parsed
    // data structure rather than as strings, so it is much more robust.

    if (!_3COpts.EnableCCTypeChecker)
      // Corresponds to the -f3c-tool compiler option.
      Invocation->LangOpts->_3C = true;

    // Re-canonicalize the path of the main source file, in case it was
    // overridden by the compilation database after it was originally
    // canonicalized by the _3CInterface constructor. This completely fixes
    // https://github.com/correctcomputation/checkedc-clang/issues/515 and
    // https://github.com/correctcomputation/checkedc-clang/issues/604 for the
    // main source file.
    //
    // If https://github.com/correctcomputation/checkedc-clang/issues/604 were
    // fixed another way, then making the path absolute would be sufficient to
    // fix https://github.com/correctcomputation/checkedc-clang/issues/515; the
    // path wouldn't need to be canonical.
    SmallVectorImpl<FrontendInputFile> &Inputs =
        Invocation->getFrontendOpts().Inputs;
    for (FrontendInputFile *Iter = Inputs.begin(); Iter < Inputs.end();
         Iter++) {
      FrontendInputFile &OldInput = *Iter;
      // getFile will assert that the input is a file, which should be true for
      // 3C.
      std::string OldPath = std::string(OldInput.getFile()), NewPath;
      std::error_code EC = tryGetCanonicalFilePath(OldPath, NewPath);
      if (EC) {
        // If the compilation database specifies a bogus, inaccessible file,
        // that will normally be caught by Driver::DiagnoseInputExistence before
        // we get here.
        errs() << "3C error: Failed to re-canonicalize source file path "
               << OldPath << " during compiler invocation: " << EC.message()
               << "\n";
        return false;
      }
      *Iter =
          FrontendInputFile(NewPath, OldInput.getKind(), OldInput.isSystem());
    }

    // Canonicalize -I paths to address the same two issues for `#include`d
    // files. The situation is analogous except that this is not a complete fix
    // for https://github.com/correctcomputation/checkedc-clang/issues/604
    // because the portion of the path in the `#include` directive may be
    // non-canonical.
    HeaderSearchOptions &HeaderOpts = *Invocation->HeaderSearchOpts;
    std::vector<HeaderSearchOptions::Entry> NewUserEntries;
    for (auto It = HeaderOpts.UserEntries.begin();
         It != HeaderOpts.UserEntries.end();) {
      HeaderSearchOptions::Entry &Entry = *It;
      std::string OldPath = Entry.Path, NewPath;
      std::error_code EC = tryGetCanonicalFilePath(OldPath, NewPath);
      if (EC) {
        // Normally, if an -I directory isn't accessible, Clang seems to ignore
        // it with no diagnostic. Hopefully, removing it from the list here will
        // have the same effect and not break anything. If we kept the
        // non-canonical entry, we might benefit from any diagnostic that Clang
        // might issue in the future, but it's harder to reason about whether
        // that might re-expose the original bugs.
        It = HeaderOpts.UserEntries.erase(It);
      } else {
        Entry.Path = NewPath;
        It++;
      }
    }

    // Set up diagnostics.
    IntrusiveRefCntPtr<DiagnosticsEngine> DiagEngine =
        CompilerInstance::createDiagnostics(&Invocation->getDiagnosticOpts(),
                                            DiagConsumer,
                                            /*ShouldOwnClient=*/false);
    // The _3CDiagnosticConsumer takes ownership of and wraps the engine's
    // previous DiagnosticConsumer, i.e., the one created by
    // CompilerInstance::createDiagnostics above (which will be a
    // VerifyDiagnosticConsumer if requested via the options).
    DiagEngine->setClient(new _3CDiagnosticConsumer(*DiagEngine));

    // Finally, actually build the AST. This part is the same as in
    // ASTBuilderAction::runInvocation.

    std::unique_ptr<ASTUnit> AST = ASTUnit::LoadFromCompilerInvocation(
        Invocation, std::move(PCHContainerOps), DiagEngine, Files);
    if (!AST)
      return false;

    handleExtraProgramAction(Invocation->getFrontendOpts(),
                             AST->getASTContext());

    ASTs.push_back(std::move(AST));
    return true;
  }

private:
  void handleExtraProgramAction(FrontendOptions &Opts,
                                ASTContext &C) {
    // The Opts.ProgramAction field is normally used only by `clang -cc1` to
    // select a FrontendAction (see CreateFrontendBaseAction in
    // ExecuteCompilerInvocation.cpp) and is ignored by LibTooling tools, which
    // perform a custom FrontendAction. But we want to support at least AST
    // dumping (as an addition to 3C's normal workflow) since it's useful for
    // debugging 3C, and we prefer to honor the standard `-Xclang -ast-dump`
    // option rather than define our own tool-level option like clang-check
    // does. We could add support for more `-ast-*` options here if desired.
    switch (Opts.ProgramAction) {
    case frontend::ParseSyntaxOnly:
      // Nothing extra to do.
      break;
    case frontend::ASTDump: {
      // Code copied from ASTDumpAction::CreateASTConsumer since we don't have a
      // good way to actually use ASTDumpAction from here. :/
      //
      // XXX: Maybe we'd prefer to output this somewhere other than stdout to
      // separate it from the updated main file written to stdout? This doesn't
      // look trivial because ASTPrinter requires ownership of the output
      // stream, and it probably isn't important for the intended debugging use
      // case.
      std::unique_ptr<ASTConsumer> Dumper =
          CreateASTDumper(nullptr /*Dump to stdout.*/, Opts.ASTDumpFilter,
                          Opts.ASTDumpDecls, Opts.ASTDumpAll,
                          Opts.ASTDumpLookups, Opts.ASTDumpDeclTypes,
                          Opts.ASTDumpFormat);
      // In principle, we should call all the ASTConsumer methods the same way
      // the normal AST parsing process would, but there isn't an obvious way to
      // do that when using ASTUnit. Instead, we rely on the assumption
      // (apparently valid as of this writing) that the only ASTConsumer method
      // that has a nonempty implementation in ASTPrinter is
      // HandleTranslationUnit, and we just call HandleTranslationUnit manually.
      Dumper->HandleTranslationUnit(C);
      break;
    }
    default:
      llvm::errs() << "Warning: The requested ProgramAction is not implemented "
                      "by 3C and will be ignored.\n";
      break;
    }
  }
};

void dumpConstraintOutputJson(const std::string &PostfixStr,
                              ProgramInfo &Info) {
  if (_3COpts.DumpIntermediate) {
    std::string FilePath = _3COpts.ConstraintOutputJson + PostfixStr + ".json";
    errs() << "Writing json output to:" << FilePath << "\n";
    std::error_code Ec;
    llvm::raw_fd_ostream OutputJson(FilePath, Ec);
    if (!OutputJson.has_error()) {
      Info.dumpJson(OutputJson);
      OutputJson.close();
    } else {
      Info.dumpJson(llvm::errs());
    }
  }
}

void runSolver(ProgramInfo &Info, std::set<std::string> &SourceFiles) {
  Constraints &CS = Info.getConstraints();

  if (_3COpts.Verbose) {
    errs() << "Trying to capture Constraint Variables for all functions\n";
  }

  // Sanity check.
  assert(CS.checkInitialEnvSanity() && "Invalid initial environment. ");

  dumpConstraintOutputJson(INITIAL_OUTPUT_SUFFIX, Info);

  clock_t StartTime = clock();
  CS.solve();
  if (_3COpts.Verbose) {
    errs() << "Solver time:" << getTimeSpentInSeconds(StartTime) << "\n";
  }
}

std::unique_ptr<_3CInterface>
_3CInterface::create(const struct _3COptions &CCopt,
                     const std::vector<std::string> &SourceFileList,
                     CompilationDatabase *CompDB) {
  // See clang/docs/checkedc/3C/clang-tidy.md#_3c-name-prefix
  // NOLINTNEXTLINE(readability-identifier-naming)
  std::unique_ptr<_3CInterface> _3CInter(
      new _3CInterface(CCopt, SourceFileList, CompDB));
  if (_3CInter->ConstructionFailed) {
    return nullptr;
  }
  return _3CInter;
}

_3CInterface::_3CInterface(const struct _3COptions &CCopt,
                           const std::vector<std::string> &SourceFileList,
                           CompilationDatabase *CompDB) {

  _3COpts = CCopt;
  _3COpts.WarnRootCause |= _3COpts.WarnAllRootCause;

  llvm::InitializeAllTargets();
  llvm::InitializeAllTargetMCs();
  llvm::InitializeAllAsmPrinters();
  llvm::InitializeAllAsmParsers();

  GlobalProgramInfo = new ProgramInfo();

  ConstraintsBuilt = false;

  if (_3COpts.OutputPostfix != "-" && !_3COpts.OutputDir.empty()) {
    errs() << "3C initialization error: Cannot use both -output-postfix and "
              "-output-dir\n";
    ConstructionFailed = true;
    return;
  }
  if (_3COpts.OutputPostfix == "-" && _3COpts.OutputDir.empty() &&
      SourceFileList.size() > 1) {
    errs() << "3C initialization error: Cannot specify more than one input "
              "file when output is to stdout\n";
    ConstructionFailed = true;
    return;
  }

  std::string TmpPath;
  std::error_code EC;

  if (_3COpts.BaseDir.empty()) {
    _3COpts.BaseDir = ".";
  }

  // Get the canonical path of the base directory.
  TmpPath = _3COpts.BaseDir;
  EC = tryGetCanonicalFilePath(_3COpts.BaseDir, TmpPath);
  if (EC) {
    errs() << "3C initialization error: Failed to canonicalize base directory "
           << "\"" << _3COpts.BaseDir << "\": " << EC.message() << "\n";
    ConstructionFailed = true;
    return;
  }
  _3COpts.BaseDir = TmpPath;

  if (!_3COpts.OutputDir.empty()) {
    // tryGetCanonicalFilePath will fail if the output dir doesn't exist yet, so
    // create it first.
    EC = llvm::sys::fs::create_directories(_3COpts.OutputDir);
    if (EC) {
      errs() << "3C initialization error: Failed to create output directory \""
             << _3COpts.OutputDir << "\": " << EC.message() << "\n";
      ConstructionFailed = true;
      return;
    }
    TmpPath = _3COpts.OutputDir;
    EC = tryGetCanonicalFilePath(_3COpts.OutputDir, TmpPath);
    if (EC) {
      errs() << "3C initialization error: Failed to canonicalize output "
             << "directory \"" << _3COpts.OutputDir << "\": " << EC.message()
             << "\n";
      ConstructionFailed = true;
      return;
    }
    _3COpts.OutputDir = TmpPath;
  }

  SourceFiles = SourceFileList;

  bool SawInputOutsideBaseDir = false;
  for (const auto &S : SourceFiles) {
    std::string AbsPath;
    EC = tryGetCanonicalFilePath(S, AbsPath);
    if (EC) {
      errs() << "3C initialization error: Failed to canonicalize source file "
             << "path \"" << S << "\": " << EC.message() << "\n";
      ConstructionFailed = true;
      continue;
    }
    FilePaths.insert(AbsPath);
    if (!filePathStartsWith(AbsPath, _3COpts.BaseDir)) {
      errs()
          << "3C initialization "
          << (_3COpts.OutputDir != "" || !_3COpts.AllowSourcesOutsideBaseDir
                  ? "error"
                  : "warning")
          << ": File \"" << AbsPath
          << "\" specified on the command line is outside the base directory\n";
      SawInputOutsideBaseDir = true;
    }
  }
  if (SawInputOutsideBaseDir) {
    errs() << "The base directory is currently \"" << _3COpts.BaseDir
           << "\" and can be changed with the -base-dir option.\n";
    if (_3COpts.OutputDir != "") {
      ConstructionFailed = true;
      errs() << "When using -output-dir, input files outside the base "
                "directory cannot be handled because there is no way to "
                "compute their output paths.\n";
    } else if (!_3COpts.AllowSourcesOutsideBaseDir) {
      ConstructionFailed = true;
      errs() << "You can use the -allow-sources-outside-base-dir option to "
                "temporarily downgrade this error to a warning.\n";
    }
  }

  CurrCompDB = CompDB;

  GlobalProgramInfo->getPerfStats().startTotalTime();
}

_3CInterface::~_3CInterface() {
  if(GlobalProgramInfo)
    delete (GlobalProgramInfo);
  assert(ConstructionFailed || DeterminedExitCode);
}

bool _3CInterface::isSuccessfulSoFar() {
  if (HadNonDiagnosticError)
    return false;
  for (auto &TU : ASTs)
    if (TU->getDiagnostics().getClient()->getNumErrors() > 0)
      return false;
  return true;
}

int _3CInterface::determineExitCode() {
  assert(!DeterminedExitCode);
  DeterminedExitCode = true;

  bool Success = isSuccessfulSoFar();

  bool SuccessAfterDiagnosticVerification = !HadNonDiagnosticError;
  for (auto &TU : ASTs)
    SuccessAfterDiagnosticVerification &=
        ((_3CDiagnosticConsumer *)TU->getDiagnostics().getClient())
            ->finish3CAnalysis();

  if (!Success && SuccessAfterDiagnosticVerification)
    // In this case, the `3c` tool will typically just have printed a "Failure
    // occurred while X... Exiting" message. If we let that be the last word, it
    // could confuse the user.
    llvm::errs() << "(Note: Exiting successfully because the failure was due "
                    "solely to expected error diagnostics and diagnostic "
                    "verification succeeded.)\n";

  return (SuccessAfterDiagnosticVerification ? 0 : 1);
}

bool _3CInterface::parseASTs() {

  std::lock_guard<std::mutex> Lock(InterfaceMutex);

  auto *Tool = new ClangTool(*CurrCompDB, SourceFiles);

  // load the ASTs
  _3CASTBuilderAction Action(ASTs);
  int ToolExitStatus = Tool->run(&Action);
  HadNonDiagnosticError |= (ToolExitStatus != 0);

  GlobalProgramInfo->registerTranslationUnits(ASTs);

  return isSuccessfulSoFar();
}

bool _3CInterface::addVariables() {

  std::lock_guard<std::mutex> Lock(InterfaceMutex);

  // Find multi-decls and assign names to unnamed inline TagDecls now so that
  // the assigned type names are available when we construct ConstraintVariables
  // for the multi-decl members in the "Add Variables" step below.
  for (auto &TU : ASTs)
    GlobalProgramInfo->TheMultiDeclsInfo.findUsedTagNames(TU->getASTContext());
  if (!isSuccessfulSoFar())
    return false;
  for (auto &TU : ASTs)
    GlobalProgramInfo->TheMultiDeclsInfo.findMultiDecls(TU->getASTContext());
  if (!isSuccessfulSoFar())
    return false;

  // 1. Add Variables.
  VariableAdderConsumer VA = VariableAdderConsumer(*GlobalProgramInfo, nullptr);
  for (auto &TU : ASTs)
    VA.HandleTranslationUnit(TU->getASTContext());

  return isSuccessfulSoFar();
}

bool _3CInterface::buildInitialConstraints() {

  std::lock_guard<std::mutex> Lock(InterfaceMutex);

  if (!GlobalProgramInfo->link()) {
    errs() << "Linking failed!\n";
    HadNonDiagnosticError = true;
    return isSuccessfulSoFar(); // False, of course, but follow the pattern.
  }

  // 2. Gather constraints.
  ConstraintBuilderConsumer CB =
      ConstraintBuilderConsumer(*GlobalProgramInfo, nullptr);
  for (auto &TU : ASTs)
    CB.HandleTranslationUnit(TU->getASTContext());
  if (!isSuccessfulSoFar())
    return false;

  ConstraintsBuilt = true;

  return isSuccessfulSoFar();
}

bool _3CInterface::solveConstraints() {
  std::lock_guard<std::mutex> Lock(InterfaceMutex);
  assert(ConstraintsBuilt && "Constraints not yet built. We need to call "
                             "build constraint before trying to solve them.");
  // 3. Solve constraints.
  if (_3COpts.Verbose)
    errs() << "Solving constraints\n";

  if (_3COpts.DumpIntermediate)
    GlobalProgramInfo->dump();

  auto &PStats = GlobalProgramInfo->getPerfStats();

  PStats.startConstraintSolverTime();
  runSolver(*GlobalProgramInfo, FilePaths);
  PStats.endConstraintSolverTime();

  if (_3COpts.Verbose)
    errs() << "Constraints solved\n";

  if (_3COpts.WarnRootCause)
    assert(CStateisclear=true);
    GlobalProgramInfo->computeInterimConstraintState(FilePaths);

  if (_3COpts.DumpIntermediate)
    dumpConstraintOutputJson(FINAL_OUTPUT_SUFFIX, *GlobalProgramInfo);

  if (_3COpts.AllTypes) {
    // Add declared bounds for all constant sized arrays. This needs to happen
    // after constraint solving because the bound added depends on whether the
    // array is NTARR or ARR.
    GlobalProgramInfo->getABoundsInfo().addConstantArrayBounds(
      *GlobalProgramInfo);

    if (_3COpts.DebugArrSolver)
      GlobalProgramInfo->getABoundsInfo().dumpAVarGraph(
          "arr_bounds_initial.dot");

    // Infer lower bounds for pointers that are not valid lower bounds.
    // The result of this inference is required for length inference, so
    // this call must be before the subsequent call to performFlowAnalysis.
    GlobalProgramInfo->getABoundsInfo().inferLowerBounds(*&GlobalProgramInfo);

    // Propagate initial data-flow information for Array pointers from
    // bounds declarations.
    GlobalProgramInfo->getABoundsInfo().performFlowAnalysis(*&GlobalProgramInfo);

    // 4. Infer the bounds based on calls to malloc and calloc
    AllocBasedBoundsInference ABBI =
        AllocBasedBoundsInference(*GlobalProgramInfo, nullptr);
    for (auto &TU : ASTs)
      ABBI.HandleTranslationUnit(TU->getASTContext());
    if (!isSuccessfulSoFar())
      return false;

    // Propagate the information from allocator bounds.
    GlobalProgramInfo->getABoundsInfo().performFlowAnalysis(*&GlobalProgramInfo);
  }

  // 5. Run intermediate tool hook to run visitors that need to be executed
  // after constraint solving but before rewriting.
  IntermediateToolHook ITH = IntermediateToolHook(*GlobalProgramInfo, nullptr);
  for (auto &TU : ASTs)
    ITH.HandleTranslationUnit(TU->getASTContext());
  if (!isSuccessfulSoFar())
    return false;

  if (_3COpts.AllTypes) {
    // Propagate data-flow information for Array pointers.
    GlobalProgramInfo->getABoundsInfo().performFlowAnalysis(*&GlobalProgramInfo);

    /*if (DebugArrSolver)
      GlobalProgramInfo->getABoundsInfo().dumpAVarGraph(
          "arr_bounds_final.dot");*/
  }

  /*if (DumpStats) {
    GlobalProgramInfo->printStats(FilePaths, llvm::errs(), true);
    GlobalProgramInfo->computeInterimConstraintState(FilePaths);
    std::error_code Ec;
    llvm::raw_fd_ostream OutputJson(StatsOutputJson, Ec);
    if (!OutputJson.has_error()) {
      GlobalProgramInfo->printStats(FilePaths, OutputJson, false, true);
      OutputJson.close();
    }
    std::string AggregateStats = StatsOutputJson + ".aggregate.json";
    llvm::raw_fd_ostream AggrJson(AggregateStats, Ec);
    if (!AggrJson.has_error()) {
      GlobalProgramInfo->printAggregateStats(FilePaths, AggrJson);
      AggrJson.close();
    }

    llvm::raw_fd_ostream WildPtrInfo(WildPtrInfoJson, Ec);
    if (!WildPtrInfo.has_error()) {
      GlobalProgramInfo->getInterimConstraintState().printStats(WildPtrInfo);
      WildPtrInfo.close();
    }

    llvm::raw_fd_ostream PerWildPtrInfo(PerWildPtrInfoJson, Ec);
    if (!PerWildPtrInfo.has_error()) {
      GlobalProgramInfo->getInterimConstraintState().printRootCauseStats(
          PerWildPtrInfo, GlobalProgramInfo->getConstraints());
      PerWildPtrInfo.close();
    }
  }*/

  return isSuccessfulSoFar();
}

bool _3CInterface::writeAllConvertedFilesToDisk() {
  std::lock_guard<std::mutex> Lock(InterfaceMutex);

  // 6. Rewrite the input files.
  RewriteConsumer RC = RewriteConsumer(*GlobalProgramInfo);
  for (auto &TU : ASTs)
    RC.HandleTranslationUnit(TU->getASTContext());

  GlobalProgramInfo->getPerfStats().endTotalTime();
  GlobalProgramInfo->getPerfStats().startTotalTime();
  return isSuccessfulSoFar();
}

bool _3CInterface::dumpStats() {
  if (_3COpts.AllTypes && _3COpts.DebugArrSolver) {
    GlobalProgramInfo->getABoundsInfo().dumpAVarGraph("arr_bounds_final.dot");
  }

  if (_3COpts.DumpStats) {
    GlobalProgramInfo->printStats(FilePaths, llvm::errs(), true);
    assert(CStateisclear=true);
    GlobalProgramInfo->computeInterimConstraintState(FilePaths);
    std::error_code Ec;
    llvm::raw_fd_ostream OutputJson(_3COpts.StatsOutputJson, Ec);
    if (!OutputJson.has_error()) {
      GlobalProgramInfo->printStats(FilePaths, OutputJson, false, true);
      OutputJson.close();
    }
    std::string AggregateStats = _3COpts.StatsOutputJson + ".aggregate.json";
    llvm::raw_fd_ostream AggrJson(AggregateStats, Ec);
    if (!AggrJson.has_error()) {
      GlobalProgramInfo->printAggregateStats(FilePaths, AggrJson);
      AggrJson.close();
    }

    llvm::raw_fd_ostream WildPtrInfo(_3COpts.WildPtrInfoJson, Ec);
    if (!WildPtrInfo.has_error()) {
      GlobalProgramInfo->getInterimConstraintState().printStats(WildPtrInfo);
      WildPtrInfo.close();
    }

    llvm::raw_fd_ostream PerWildPtrInfo(_3COpts.PerWildPtrInfoJson, Ec);
    if (!PerWildPtrInfo.has_error()) {
      GlobalProgramInfo->getInterimConstraintState().printRootCauseStats(
          PerWildPtrInfo, GlobalProgramInfo->getConstraints());
      PerWildPtrInfo.close();
    }
  }
  return isSuccessfulSoFar();
}

ConstraintsInfo &_3CInterface::getWildPtrsInfo() {
  return GlobalProgramInfo->getInterimConstraintState();
}

void _3CInterface::invalidateAllConstraintsWithReason(
    Constraint *ConstraintToRemove) {
  // Get the reason for the current constraint.
  std::string ConstraintRsn = ConstraintToRemove->getReasonText();
  Constraints::ConstraintSet ToRemoveConstraints;
  Constraints &CS = GlobalProgramInfo->getConstraints();
  // Remove all constraints that have the reason.
  CS.removeAllConstraintsOnReason(ConstraintRsn, ToRemoveConstraints);

  // Free up memory by deleting all the removed constraints.
  for (auto *ToDelCons : ToRemoveConstraints) {
    assert(dyn_cast<Geq>(ToDelCons) && "We can only delete Geq constraints.");
    Geq *TCons = dyn_cast<Geq>(ToDelCons);
    auto *Vatom = dyn_cast<VarAtom>(TCons->getLHS());
    assert(Vatom != nullptr && "Equality constraint with out VarAtom as LHS");
    VarAtom *VS = CS.getOrCreateVar(Vatom->getLoc(), "q", VarAtom::V_Other);
    VS->getAllConstraints().erase(TCons);
    delete (ToDelCons);
  }
}
bool _3CInterface::makeSinglePtrNonWild(ConstraintKey TargetPtr) {
  std::lock_guard<std::mutex> Lock(InterfaceMutex);
  CVars RemovePtrs;
  RemovePtrs.clear();

  auto &PtrDisjointSet = GlobalProgramInfo->getInterimConstraintState();
  auto &CS = GlobalProgramInfo->getConstraints();

  CVars OldWildPtrs = PtrDisjointSet.AllWildAtoms;

  //Delete the constraint that makes the target non-wild

  VarAtom *VA = CS.getOrCreateVar(TargetPtr,"q",VarAtom::V_Other);
  Geq newE(VA, CS.getWild(),ReasonLoc());
  Constraint *originalConstraint = *CS.getConstraints().find(&newE);
  CS.removeConstraint(originalConstraint);
  VA->getAllConstraints().erase(originalConstraint);

  delete(originalConstraint);

  // Reset the constraint system.
  CS.resetEnvironment();

  // Solve the constraints.
  //assert (CS == GlobalProgramInfo->getConstraints());
  runSolver(*GlobalProgramInfo, FilePaths);

  // Compute new disjoint set.
  assert(CStateisclear=true);
  GlobalProgramInfo->computeInterimConstraintState(FilePaths);

  // Get new WILD pointers.
  CVars &NewWildPtrs = PtrDisjointSet.AllWildAtoms;

  // Get the number of pointers that have now converted to non-WILD.
  std::set_difference(OldWildPtrs.begin(), OldWildPtrs.end(),
                      NewWildPtrs.begin(), NewWildPtrs.end(),
                      std::inserter(RemovePtrs, RemovePtrs.begin()));

  return !RemovePtrs.empty();
}
bool _3CInterface::invalidateWildReasonGlobally(ConstraintKey PtrKey) {
  std::lock_guard<std::mutex> Lock(InterfaceMutex);

  CVars RemovePtrs;
  RemovePtrs.clear();

  auto &PtrDisjointSet = GlobalProgramInfo->getInterimConstraintState();
  auto &CS = GlobalProgramInfo->getConstraints();

  CVars OldWildPtrs = PtrDisjointSet.AllWildAtoms;

  // Delete ALL the constraints that have the same given reason.
  VarAtom *VA = CS.getOrCreateVar(PtrKey, "q", VarAtom::V_Other);
  Geq NewE(VA, CS.getWild(),ReasonLoc());
  Constraint *OriginalConstraint = *CS.getConstraints().find(&NewE);
  invalidateAllConstraintsWithReason(OriginalConstraint);

  // Reset constraint solver.
  CS.resetEnvironment();

  // Solve the constraints.
  runSolver(*GlobalProgramInfo, FilePaths);

  // Recompute the WILD pointer disjoint sets.
  assert(CStateisclear=true);
    GlobalProgramInfo->computeInterimConstraintState(FilePaths);

  // Computed the number of removed pointers.
  CVars &NewWildPtrs = PtrDisjointSet.AllWildAtoms;

  std::set_difference(OldWildPtrs.begin(), OldWildPtrs.end(),
                      NewWildPtrs.begin(), NewWildPtrs.end(),
                      std::inserter(RemovePtrs, RemovePtrs.begin()));

  return !RemovePtrs.empty();
}

void _3CInterface::resetInterface() {
  if(GlobalProgramInfo)
    delete (GlobalProgramInfo);
  GlobalProgramInfo = new ProgramInfo();
  //GlobalProgramInfo->clear();
  ASTs.clear();
}


